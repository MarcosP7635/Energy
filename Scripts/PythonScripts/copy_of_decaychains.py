"""Copy of DecayChains.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1OV-VbkoZxKvjt0g9t0rD8lM7KbhuZRuI
"""

import astropy.units as units
import astropy.constants as constants
import matplotlib.pyplot as plt
import sympy as sym
import numpy as np 
import pandas as pd
import plotly.express as px
import plotly.figure_factory as ff
import plotly.graph_objects as go
import requests
import re
import subprocess
import urllib.request
from sympy.abc import *
from bs4 import BeautifulSoup
import csv
cwd = subprocess.os.getcwd()

def half_life_to_lambda(half_life):
    '''
    This function takes the e-folding times of the entire decay chain.
    Returns the half-life of the nuclide
    '''
    return half_life / np.log(2)

nuclide_df = pd.read_csv(cwd + '\\NuclideData.csv').iloc[:,1:]
half_lives = nuclide_df['Half life (years)'].to_numpy() 
nuclide_df["e Folding Time (seconds)"] = half_life_to_lambda(half_lives * units.year.to(units.s))
nuclide_df

element_symbols = ['H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 
'F', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 
'Ca', 'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 
'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 
'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 
'Sn', 'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 
'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm',
 'Yb', 'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 
 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 
 'Th', 'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 
 'Fm', 'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt',
  'Ds', 'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og', 'N/A']
len(element_symbols)
#to find the daughter nuclide we only need to increment by 1 in the element symbols.
element_symbols[element_symbols.index('Ni')+1]
#remove numbers from string
s = element_symbols
nuclide_df['Daugher Nucleus'] = [re.sub('\D+', '', n) + s[s.index(re.sub('\d+', '', n))+1] 
if re.sub('\d+', '', n) in s else 'N/A' for n in nuclide_df['Isotope'] ]

def get_isotope_info(isotope, info = None, isotope_column = None,
    dataset = {}, isotope_list = None, lists_to_search = []):                  
  '''
  isotope_list and list_to_search are optional arguments.
  If list_to_search is not provided, then info must be provided.
  If isotope_list is not provided, then dataset and isotope_column
  must be provided.
  '''
  if isotope_list is None:
    isotope_list = list(dataset[isotope_column])
  row = isotope_list.index(isotope)
  if len(lists_to_search) == 0:
    try:
      lists_to_search = list(dataset[info])
    except:
      print("info to search for not entered")
      return
  try: #only works if there are multiple specified lists to search 
    return [target_list[row] for target_list in lists_to_search]
  except:
    return lists_to_search[row]

isotope_list = list(nuclide_df['Isotope'])
lambda_list = list(nuclide_df['e Folding Time (seconds)'])
decay_energy_list = list(nuclide_df['Average beta decay energy'])
daughter_list = list(nuclide_df['Daugher Nucleus'])

def make_decay_chain(isotope, isotope_list, lambda_list, decay_energy_list, daughter_list):
    '''
    This function takes the isotope, e-folding times, and daughter nuclides
    and returns the decay chain.
    '''
    decay_chain = {}
    decay_chain[isotope] = get_isotope_info(isotope, isotope_list = isotope_list, 
        lists_to_search = (lambda_list, decay_energy_list, daughter_list))
    while True:
        isotope = decay_chain[isotope][2]
        try:
            decay_chain[isotope] = get_isotope_info(isotope, isotope_list = isotope_list,
                lists_to_search = (lambda_list, decay_energy_list, daughter_list))
            if(isotope == decay_chain[isotope][2]):
                return decay_chain
        except:
            return pd.DataFrame(decay_chain, index= ("e-Folding Time (seconds)", 
                                "Average beta-decay energy", "Daughter")).transpose()

#Quickly calculating the decay rate of the i-th generation nuclide
def formulate_decay_rate(e_folding_times):
    '''
    The e-folding times must be in a numpy array.
    Returns a formula for the decay rate of each generation. 
    '''
    exponent_array = -1 / e_folding_times
    decay_rates = len(exponent_array)  * [sym.N(0)]
    decay_rates[0] = sym.exp(t * exponent_array[0]) * exponent_array[0]
    for index, L in enumerate(exponent_array[1:]):
        decay_rates[index+1] = decay_rates[index] * (1 + sym.exp(t * L) * L) 
    return decay_rates

def eval_decay_rates(decay_rates, time_array):
    '''
    This function takes the formula for the decay rate of each generation
    and substitutes each value in the time array for t.
    Each decay_rate must be a sympy expression. 
    https://docs.sympy.org/ 
    Rewrite so that the outer loop is over the time array and the inner loop
    is over the generations. This can be done by using (suggested by copilot: 
    the np.meshgrid function) or a 2d array (my first thought)
    '''
    try: #will only evaluate if decay_rates is an array of sympy expressions
        evaluated_decay_rates = [np.array([formula.subs(t, time) for formula in decay_rates])
                                    for time in time_array]
    except:
        evaluated_decay_rates = [decay_rates.subs(t, time) for time in time_array]
    return evaluated_decay_rates


#Calculating the power density of a decay chain
def calc_power_density(decay_rates, decay_energies, initial_mass):
    '''
    Rewrite such that is sums the entire chain and NOT across time
    decay_rates must be a numpy array in moles/second
    decay_energies must be a numpy array in keV/decay
    This function takes the decay rates and energies of the decay chain.
    Returns the power density in watts/g
    '''
    power_density =  [sum(decay_rate_t * decay_energies) for decay_rate_t in decay_rates]
    '''
    At every different value for time, 
    store the sum of the product of each generation's decay rate and decay energy.
    '''
    power_density = np.array(power_density)
    #convert to W/g
    power_density *=  units.keV.to(units.J) * float(constants.N_A * units.mol) / initial_mass
    return np.abs(power_density.astype(float))

chain = make_decay_chain('32Si', isotope_list, lambda_list, decay_energy_list, daughter_list)
chain

decay_rates = formulate_decay_rate(chain['e-Folding Time (seconds)'])
#currently, eval_decay_rates evalautes in < 1 second for 100 time points and 6 generations
time_array = np.logspace(1, 9.5, 10**2)
n_decay_rates = eval_decay_rates(decay_rates, time_array)
n_decay_rates

t_power_densities = calc_power_density(decay_rates = n_decay_rates, decay_energies = np.array(chain['Average beta-decay energy']),
        initial_mass = float(re.sub('\D+', '', chain.index[0])))
px.scatter(y=t_power_densities, x= time_array, log_x=True, log_y=True,
        labels={'x': 'Time (seconds)', 'y': 'Power Density (W/g)'}, title = 'Power Density of ' + chain.index[0] + ' Decay Chain')
#THIS IS MUCH HIGHER THAN WHAT I HAVE IN THE DECADE HALF LIVES POWER DENSITIES ON GITHUB!!!
#Double check decay formulas!!!!

time_array

all_decay_chains = [make_decay_chain(isotope, isotope_list, lambda_list, decay_energy_list, daughter_list) 
                    for isotope in isotope_list]
time_array = np.logspace(1, 9.5, 10)
def calculate_all_power_densities(all_decay_chains, time_array, mean = True):
    '''
    This function takes the isotope, e-folding times, and daughter nuclides
    and returns power density as a function of time for each decay chain.
    The optional boolean argument mean determines whether the whole time series is returned
    or only its mean. 
    '''
    if mean:
        all_power_densities = [np.mean(calc_power_density(
                                    decay_rates = eval_decay_rates(
                                                    formulate_decay_rate(chain['e-Folding Time (seconds)']), 
                                                    time_array), 
                                    decay_energies = np.array(chain['Average beta-decay energy']),
                                    initial_mass = float(re.sub('\D+', '', chain.index[0]))
                                )) for chain in all_decay_chains]
    else:
        all_power_densities = [calc_power_density(
                                    decay_rates = eval_decay_rates(
                                                    formulate_decay_rate(chain['e-Folding Time (seconds)']), 
                                                    time_array), 
                                    decay_energies = np.array(chain['Average beta-decay energy']),
                                    initial_mass = float(re.sub('\D+', '', chain.index[0]))
                                ) for chain in all_decay_chains]
    return all_power_densities

mean_power_densities = calculate_all_power_densities(all_decay_chains[:2], time_array, mean = True)

3.7 * len(all_decay_chains) * units.second.to(units.h) / 2
#it will take 2 hours to run my script in jupyter. I'l convert it to a python script and run it in pypy to see if it's faster.

def clean_time_series(time_series):
    '''
    This function takes the time series of power densities and returns a list
    of lists of the time series converted into floats.
    '''
    split_time_series = time_series.replace('[', ' ').replace(']', ' ').replace('\n', ' ').split(' ') 
    return np.round(np.array([float(power_density)  
                    for power_density in split_time_series 
                    if len(power_density)>0]), 3)

time_series_file_path = cwd + '\MeanPowerDensitiesofDecayChains\power_density_time_series.csv'
#read the file to a numpy array
with open(time_series_file_path, newline='\n') as f:
    reader = csv.reader(f)
    time_series_unclean = list(reader)[0]
power_densities_dict = {}
power_densities_dict['Time (years)'] = np.logspace(0, 9.5, 10**3) * float(units.second.to(units.year))
for row, chain in enumerate(all_decay_chains):
    power_densities_dict[chain.index[0]] = clean_time_series(time_series_unclean[row])
power_densities_df = pd.DataFrame.from_dict(power_densities_dict).set_index(
                        'Time (years)')
power_densities_df

#plot multiple scatterplots together with hover names
indices = power_densities_df.index

#plot multiple scatterplots together with hover names
indices = power_densities_df.index
min_time = 1
for index in indices:
    if index > min_time:
        min_time = index
        break
min_index = indices.get_loc(min_time)
print(min_index)
fig = go.Figure()
for column in power_densities_df.columns:
    if (power_densities_df[column][min_time] > 0):
        fig.add_traces(go.Scatter(x = indices[min_index:], 
        y = power_densities_df[column][min_time:], 
        mode='markers', name = column)) 
fig.update_xaxes(title = 'Time (years)')
fig.update_yaxes(title = 'Power Density (W/g)', type = 'log')
fig.update_layout(title = 'Power Density as a Function of Time')
print("Made the figure")
fig.show()

